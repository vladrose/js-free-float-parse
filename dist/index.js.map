{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["type Options = {\n  precision?: number\n  min?: number\n  max?: number\n  /**\n   * Returns dot as float divider\n   * */\n  dot?: boolean\n}\n\nfunction replaceDotByComma(input: string, dot = false) {\n  return dot ? input : input.replace(\".\", \",\")\n}\n\nexport default function jsFreeFloatParse(input: string, options?: Options) {\n  const { precision = 16, min = -Infinity, max = Infinity, dot = false } = options || {}\n\n  let outputString: string = \"\"\n  let outputNumber: number = 0\n\n  if (!input) {\n    return [outputString, outputNumber] as const\n  }\n\n  // Some short exceptions\n  switch (true) {\n    case input === \",\":\n    case input === \".\": {\n      outputString = dot ? \"0.0\" : \"0,0\"\n      return [outputString, outputNumber] as const\n    }\n    case input === \"0,\":\n    case input === \"0.\": {\n      outputString = dot ? \"0.\" : \"0,\"\n      return [outputString, outputNumber] as const\n    }\n    case input === \"-\": {\n      outputString = \"-\"\n      return [outputString, outputNumber] as const\n    }\n    case input === \"-0\": {\n      outputString = \"-0\"\n      return [outputString, outputNumber] as const\n    }\n    case input === \"-0,\":\n    case input === \"-0.\": {\n      outputString = dot ? \"-0.\" : \"-0,\"\n      return [outputString, outputNumber] as const\n    }\n  }\n\n  const isNegative = input.startsWith(\"-\")\n\n  // Remove non-digit signs excluding dot and comma\n  input = input.replace(/[^\\d.,]/g, \"\")\n\n  // Replace all commas with dots\n  input = input.replaceAll(\",\", \".\")\n\n  // Remove leading dots\n  input = input.replace(/^\\.*/, \"\")\n\n  // Remove multiple dots\n  const dotParts = input.split(\".\")\n  // Means we have more than one dot\n  if (dotParts.length > 2) {\n    const [firstPart, ...restParts] = dotParts\n    const firstPartNumber = parseFloat(firstPart)\n    const isFirstPartNumber = !isNaN(firstPartNumber)\n    if (isFirstPartNumber) {\n      const noDotsRestParts = restParts.join(\"\")\n      input = [firstPart, noDotsRestParts].join(\".\")\n    }\n  }\n\n  // Remove leading zeros\n  if (input.startsWith(\"0\")) {\n    input = input.replace(/^0*(?=\\d)/, \"\")\n  }\n\n  // Return negative sign back after removing\n  if (isNegative) {\n    input = \"-\" + input\n  }\n\n  // Round numbers with precision\n  const currentNumber = parseFloat(input)\n  if (!isNaN(currentNumber)) {\n    const [, decimalPlaces] = input.split(\".\")\n    if (decimalPlaces && decimalPlaces.length > precision) {\n      const numberWithPrecision = parseFloat(currentNumber.toFixed(precision))\n      input = numberWithPrecision.toString()\n    }\n  } else {\n    // Final check\n    throw new Error(`jsFreeFloatParse: Failed to parse ${input}`)\n  }\n\n  outputNumber = parseFloat(input)\n  // Assume we have 0 or 1 dot here\n  outputString = replaceDotByComma(input, dot)\n\n  // Apply min/max\n  if (min > outputNumber) {\n    outputNumber = min\n    outputString = replaceDotByComma(min.toString(), dot)\n  }\n\n  // Apply min/max\n  if (max < outputNumber) {\n    outputNumber = max\n    outputString = replaceDotByComma(max.toString(), dot)\n  }\n\n  return [outputString, outputNumber] as const\n}\n"]}